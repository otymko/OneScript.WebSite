
# ПотокВПамяти / MemoryStream

    
    

Представляет собой поток данных, который можно последовательно читать и/или в который можно последовательно писать.
Экземпляры объектов данного типа можно получить с помощью различных методов других объектов.


  
  
## Свойства
    
### ДоступнаЗапись / CanWrite
Доступ: Чтение

Тип значения: Булево (Boolean)

    
    

Признак доступности записи в поток.


  
  
### ДоступноИзменениеПозиции / CanSeek
Доступ: Чтение

Тип значения: Булево (Boolean)

    
    

Признак доступности произвольного изменения позиции чтения/записи в потоке.


  
  
### ДоступноЧтение / CanRead
Доступ: Чтение

Тип значения: Булево (Boolean)

    
    

Признак доступности чтения из потока.


  
  
### ДоступенТаймаут / CanTimeout
Доступ: Чтение

Тип значения: Булево (Boolean)

    
    

Признак доступности установки таймаута чтения/записи в потоке.


  
  
### ТаймаутЧтения / ReadTimeout
Доступ: Чтение/Запись

Тип значения: Число (int)

    
    

Время в миллисекундах, отведенное потоку на операцию чтения.


  
  
### ТаймаутЗаписи / WriteTimeout
Доступ: Чтение/Запись

Тип значения: Число (int)

    
    

Время в миллисекундах, отведенное потоку на операцию записи.


  
  
## Методы
    
### Закрыть / Close()
    
    
    

Вызов данного метода завершает работу с потоком. При попытке вызвать любой метод объекта, кроме метода Закрыть, будет вызвано исключение.
При повторном вызове данного метода никаких действий выполняться не будет.
Выполняемое действие зависит от используемого типа потока.


  
  
### Записать / Write()
    
    
    

Записывает в поток заданное количество байтов из буфера по заданному смещению. Если в буфере меньше данных, чем требуется записать, вызывается исключение о недостаточном количестве данных в буфере.
Запись в поток возможна только, если поток поддерживает запись. В противном случае при вызове метода будет вызвано исключение.


  
  
#### Параметры

* *buffer*: Буфер, из которого выбираются данные для записи.

* *positionInBuffer*: Позиция в буфере, начиная с которой данные будут получены для записи в поток.

* *number*: Количество байт, которые требуется записать.

### КопироватьВ / CopyTo()
    
    
    

Копирует данные из текущего потока в другой поток.


  
  
#### Параметры

* *targetStream*: Поток, в который будет выполняться копирование.

* *bufferSize*: Размер буфера, используемого при копировании.
Если параметр не задан, то система подбирает размер буфера автоматически.

### Перейти / Seek()
    
    
    

Сдвигает текущую позицию потока на заданное количество байтов относительно начальной позиции. Если указано отрицательное смещение, позиция сдвигается в направлении к началу потока.
Если изменение позиции недоступно (ДоступноИзменениеПозиции установлено в Ложь), будет сгенерировано исключение.


  
  
#### Параметры

* *offset*: Количество байтов, на которое нужно передвинуть позицию в потоке.

* *initialPosition*: Начальная позиция, от которой отсчитывается смещение.

#### Возвращаемое значение

Числовым типом может быть представлено любое десятичное число. Над данными числового типа определены основные арифметические операции: сложение, вычитание, умножение и деление. Максимально допустимая разрядность числа 38 знаков.

  
### ПолучитьПотокТолькоДляЧтения / GetReadonlyStream()
    
    
    

Возвращает поток, который разделяет данные и текущую позицию с данным потоком, но не разрешает запись.


  
  
#### Возвращаемое значение

### Прочитать / Read()
    
    
    

Выполняет чтение заданного количества байтов в указанный буфер по указанному смещению. Текущая позиция смещается вперед на фактическое количество прочитанных байтов.
Чтение из потока возможно только, если поток поддерживает чтение. В противном случае, будет вызвано исключение.
При чтении размер целевого буфера не меняется, а его содержимое перезаписывается фактически прочитанными данными. Если в буфере недостаточно места для записи прочитанных данных, происходит ошибка переполнения.


  
  
#### Параметры

* *buffer*: Буфер, в который выполняется чтение.

* *positionInBuffer*: Позиция в целевом буфере, начиная с которой требуется записывать данные из потока.

* *number*: Количество байт, которые требуется записать в целевой буфер.

#### Возвращаемое значение

Возвращает число прочитанных байт


  
### Размер / Size()
    
    
    

Получает размер данных в байтах.


  
  
### СброситьБуферы / Flush()
    
    
    

Сбрасывает все промежуточные буферы и производит запись всех незаписанных данных в целевое устройство.


  
  
### ТекущаяПозиция / CurrentPosition()
    
    
    

Возвращает текущую позицию в потоке.


  
  
#### Возвращаемое значение

Числовым типом может быть представлено любое десятичное число. Над данными числового типа определены основные арифметические операции: сложение, вычитание, умножение и деление. Максимально допустимая разрядность числа 38 знаков.

  
### УстановитьРазмер / SetSize()
    
    
    

Устанавливает размер потока.
Если текущий размер превышает заданный, поток будет сокращен до заданного размера, а информация, превышающая заданный размер, будет потеряна.
Если текущий размер потока меньше заданного, то содержимое потока между старым и новым размером не определено.


  
  
#### Параметры

* *size*: Устанавливаемый размер потока.

### ЗакрытьИПолучитьДвоичныеДанные / CloseAndGetBinaryData()
    
    
    
закрывает поток и возвращает результат в виде двоичных данных


  
  
#### Возвращаемое значение

## Конструкторы

  
### По буферу или начальной емкости
    
    

Создает поток, в качестве нижележащего хранилища для которого используется заданный байтовый буфер. Ёмкость потока ограничена размером буфера. При выходе за границы буфера будет сгенерировано исключение.
Возможность записи в поток зависит от возможности изменения передаваемого буфера.


  
  
#### Параметры

* *bufferOrCapacity*: Буфер, на основании которого будет создан поток или начальная емкость будущего потока.

### По умолчанию
    
    

Создает поток в памяти с расширяемой емкостью. Данный вариант можно использовать для работы с достаточно большими объемами данных, т.к. данные хранятся постранично, а не в виде одного последовательного блока.


  
  